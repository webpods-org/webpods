/**
 * CLI Test Helpers
 * Utilities for testing the WebPods CLI
 */

import { spawn } from "child_process";
import { promises as fs } from "fs";
import path from "path";
import { fileURLToPath } from "url";
import os from "os";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

export interface CliResult {
  stdout: string;
  stderr: string;
  exitCode: number | null;
}

export class CliTestHelper {
  private cliPath: string;
  private configDir: string;
  private server: string;

  constructor(server = "http://localhost:3456") {
    // Path to the CLI entry point
    this.cliPath = path.resolve(
      __dirname,
      "../../webpods-cli/dist/index.js"
    );
    this.server = server;
    
    // Create a temporary config directory for tests
    this.configDir = path.join(os.tmpdir(), `webpods-cli-test-${Date.now()}`);
  }

  async setup(): Promise<void> {
    // Create temporary config directory
    await fs.mkdir(this.configDir, { recursive: true });
    
    // Create initial config
    const configPath = path.join(this.configDir, "config.json");
    await fs.writeFile(
      configPath,
      JSON.stringify({
        server: this.server,
        outputFormat: "json"
      }, null, 2)
    );
  }

  async cleanup(): Promise<void> {
    // Clean up temporary config directory
    try {
      await fs.rm(this.configDir, { recursive: true, force: true });
    } catch {
      // Ignore cleanup errors
    }
  }

  /**
   * Execute a CLI command and capture output
   */
  async exec(args: string[], options: {
    token?: string;
    input?: string;
    timeout?: number;
    env?: Record<string, string>;
  } = {}): Promise<CliResult> {
    return new Promise((resolve, reject) => {
      const env = {
        ...process.env,
        HOME: this.configDir, // Use test config directory
        CLI_SILENT: "true", // Disable CLI logging during tests
        ...options.env
      };

      // Add server and token arguments if provided
      const fullArgs = [...args];
      if (!args.includes("--server")) {
        fullArgs.push("--server", this.server);
      }
      if (options.token && !args.includes("--token")) {
        fullArgs.push("--token", options.token);
      }

      const child = spawn("node", [this.cliPath, ...fullArgs], {
        env,
        timeout: options.timeout || 10000,
      });

      let stdout = "";
      let stderr = "";

      child.stdout.on("data", (data) => {
        stdout += data.toString();
      });

      child.stderr.on("data", (data) => {
        stderr += data.toString();
      });

      if (options.input) {
        child.stdin.write(options.input);
        child.stdin.end();
      }

      child.on("close", (code) => {
        resolve({
          stdout: stdout.trim(),
          stderr: stderr.trim(),
          exitCode: code,
        });
      });

      child.on("error", (err) => {
        reject(err);
      });
    });
  }

  /**
   * Set a token in the test config
   */
  async setToken(token: string): Promise<void> {
    const configPath = path.join(this.configDir, "config.json");
    const config = JSON.parse(await fs.readFile(configPath, "utf-8"));
    config.token = token;
    await fs.writeFile(configPath, JSON.stringify(config, null, 2));
  }

  /**
   * Clear the token from test config
   */
  async clearToken(): Promise<void> {
    const configPath = path.join(this.configDir, "config.json");
    const config = JSON.parse(await fs.readFile(configPath, "utf-8"));
    delete config.token;
    await fs.writeFile(configPath, JSON.stringify(config, null, 2));
  }

  /**
   * Parse JSON output from CLI
   */
  parseJson(output: string): any {
    try {
      // CLI may output additional lines, try to find JSON
      const lines = output.split("\n");
      for (let i = lines.length - 1; i >= 0; i--) {
        const line = lines[i]?.trim() || "";
        if (line.startsWith("{") || line.startsWith("[")) {
          // Try to parse from this line to the end
          const jsonStr = lines.slice(i).join("\n");
          return JSON.parse(jsonStr);
        }
      }
      // If no JSON found, try parsing the whole output
      return JSON.parse(output);
    } catch (err) {
      throw new Error(`Failed to parse JSON output: ${output}`);
    }
  }

  /**
   * Create a test JWT token
   */
  createTestToken(userId: string, email: string): string {
    // Create a simple JWT-like token for testing
    // In real tests, this would be generated by the auth system
    const header = Buffer.from(JSON.stringify({ alg: "HS256", typ: "JWT" })).toString("base64url");
    const payload = Buffer.from(JSON.stringify({
      sub: userId,
      email: email,
      iat: Math.floor(Date.now() / 1000),
      exp: Math.floor(Date.now() / 1000) + 3600,
    })).toString("base64url");
    const signature = "test-signature";
    return `${header}.${payload}.${signature}`;
  }
}